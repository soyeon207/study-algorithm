## 01-2 시간 복잡도 활용하기

버블 정렬의 시간 복잡도가 (O(n<sup>2</sup>))<br>
병합 정렬의 시간 복잡도가 (O(nlogn)) 이라고 알고 있다고 가정하고 다음 문제를 예를 들어보자

### 연습 문제 000 수 정렬하기
N 개의 수가 주어졌을 때 이를 오름차순 정렬하는 프로그램을 작성하시오.<br>
(시간 제한 2초 | 백준 온라인 저지 2750번)

#### 1. 입력 
1번째 줄에 수의 개수 N, 2번째 줄부터는 N개의 줄에 숫자가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수다. 수는 중복되지 않는다. 

#### 2. 출력 
1번째 줄부터 N개의 줄에 오름차순 정렬한 결과를 1줄에 1개씩 출력한다. 

예제 입력 1
```
5
5
2
3
4
1
```

예제 출력 1
```
1
2
3
4
5
```

- 시간 제한이 2초이기 때문에 조건을 만족하려면 2억 번 이하의 연산 횟수로 문제를 해결해야 한다. (연산 횟수는 1초에 1억 번 연산하는 것을 기준으로 생각하기 때문에)
- 그렇기 때문에 문제에서 주어진 시간 제한과 데이터 크기를 바탕으로 어떤 정렬 알고리즘을 사용해야 할지는 판단할 수 있다. 

**연산 횟수 계산 방법**
- 연산 횟수 = 알고리즘 시간 복잡도 X 데이터의 크기 

**알고리즘 적합성 평가**
- 버블 정렬 : (1,000,000)<sup>2</sup> = 1,000,000,000,000 > 200,000,000 -> 부적합 
- 병합 정렬 : 1,000,000log(1,000,000) = 약 20,000,000 < 200,000,000 -> 적합 알고리즘

즉, 해당 문제는 병합 정렬이 적합한 알고리즘이라고 판단할 수 있다. 

### 시간 복잡도를 바탕으로 코드 로직 개선하기 
시간 복잡도는 작성한 코드의 비효율적인 로직을 개선하는 바탕으로도 사용할 수 있다. 

**시간 복잡도 도출 기준**
1. 상수는 시간 복잡도 계산에서 제외한다. 
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다. 

코드를 예로 들어서 설명할 때 
```java
int N = 1000000;
int cnt = 0;

for(int i=0;i<N;i++) {
    System.out.println("연산횟수 : "+cnt++);
}
```

```java
int N = 1000000;
int cnt = 0;

for(int i=0;i<N;i++) {
    System.out.println("연산횟수 : "+cnt++);
}

for(int i=0;i<N;i++) {
    System.out.println("연산횟수 : "+cnt++);
}

for(int i=0;i<N;i++) {
    System.out.println("연산횟수 : "+cnt++);
}
```

두 예제 코드의 연산 횟수는 3배의 차이가 나지만 코딩 테스트에서는 일반적으로 상수를 무시하기 때문에 시간복잡도는 모두 O(n) 이다. 