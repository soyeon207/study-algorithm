## 10986번 나머지 합

### 문제 
수 N개 A<sub>1</sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. 이때, 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.

즉, A<sub>i</sub> + ... + A<sub>j</sub> (i ≤ j) 의 합이 M으로 나누어 떨어지는 (i, j) 쌍의 개수를 구해야 한다.

### 입력
첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 10<sup>6</sup>, 2 ≤ M ≤ 10<sup>3</sup>)

둘째 줄에 N개의 수 A<sub>1<sub>, A<sub>2</sub>, ..., A<sub>N</sub>이 주어진다. (0 ≤ A<sub>i</sub> ≤ 10<sup>9</sup>)

### 출력 
첫째 줄에 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 출력한다.

### 예시 
예제 입력 1
```
5 3
1 2 3 1 2
```

예제 출력 1
```
7
```

## 풀이
### 01단계 문제 분석하기
N 의 최댓값이 106이라 연산량이 작게 느껴질 수 있다. 하지만 잠시 생각해보면 106개의 수에 대하여 모든 구간 합을 구해야 하므로 1초 안에 연산하기는 어렵다. 여기서도 구간 합 배열을 이용해야 한다. 

**나머지 합 문제 풀이의 핵심 아이디어**
- (A + B) % C 은 ((A % C) + (B % C)) % C 와 같다. 다시 말해 특정 구간 수들의 나머지 연산을 더해 나머지 연산을 한 값과 이 구간 합의 나머지 연산을 한 값은 동일하다. 
- 구간 합 배열을 이용한 식 S[i] ~ S[j] 는 원본 배열의 j+1 부터 i 까지의 구간 합이다. 
- S[i] % M 의 값과 S[j] % M 의 값이 같다면 (S[i] ~ S[j]) % M 은 0이다. 즉, 구간 합 배열의 원소를 M으로 나눈 나머지로 업데이트하고 S[i] 와 S[j] 가 같은 (i,j) 쌍을 찾으면 원본 배열에서 j+1 부터 i까지의 구간 합이 M으로 나누어 떨어진다는 것을 알 수 있다. 

### 02단계 손으로 풀어 보기 
1. A 배열의 합 배열 S 를 생성한다. 
2. 합 배열 S 의 모든 값을 M 으로 나머지 연산을 수행해 값을 업데이트 한다. 
3. 우선 변경된 합 배열에서 원소 값이 0 인 개수만 세어 정답에 더한다. 변경된 합 배열의 원소 값이 0 이라는 뜻은 원본 배열의 0 부터 i 까지의 구간 합이 이미 M 으로 나누어떨어진다는 뜻이기 때문이다. 
4. 이제 변경된 합 배열에서 원소 값이 같은 인덱스의 개수, 즉, 나머지 값이 같은 합 배열의 개수를 센다. 변경된 합 배열에서 원소 값이 같은 2개의 원소를 뽑는 모든 경우의 수를 구하여 정답에 더하면 된다. 위의 예에서는 0이 3개, 1이 2개이므로 <sub>3</sub>C<sub>2</sub>, <sub>2</sub>C<sub>2</sub>로 경우의 수를 구하여 더하면 된다. 

### 03단계 슈도 코드 작성하기
```
N 입력받기(수열의 개수)
M 입력받기(나누어떨어져야 하는 수)
S 선언하기(합 배열)
C 선언하기(같은 나머지의 인덱스를 카운트하는 배열)
for(i-> 1~N) {
    S[i] = S[i-1]+A[i]
}

for(i -> 0 ~N) {
    remainder = S[i] %M
    if(remider ==0) 정답을 1 증가시키기
    C[remainder] 의 값을 1 증가시키기
}

for(i -> 0 ~ M) {
    C[i] (i가 나머지인 인덱스의 개수)에서 2가지를 뽑는 경우의 수를 정답에 더하기
    // C[i] 개 중 2개를 뽑는 경우의 수 계산 공식 C[i] * (C[i] - 1])/2
}

결과값 출력
```